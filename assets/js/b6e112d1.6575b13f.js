(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(8),i=(n(0),n(136)),s={title:"Use After Free (UAF) Vulnerability",sidebar_label:"Use After Free (UAF) Vulnerability"},o={unversionedId:"security_awareness/languages/C/uaf",id:"security_awareness/languages/C/uaf",isDocsHomePage:!1,title:"Use After Free (UAF) Vulnerability",description:"Description",source:"@site/docs/security_awareness/languages/C/uaf.md",slug:"/security_awareness/languages/C/uaf",permalink:"/docs/security_awareness/languages/C/uaf",version:"current",sidebar_label:"Use After Free (UAF) Vulnerability",sidebar:"someSidebar",previous:{title:"Buffer Overflow",permalink:"/docs/security_awareness/languages/C/BufferOverflow"},next:{title:"Memory Leak Vulnerability",permalink:"/docs/security_awareness/languages/C/MemoryLeak"}},l=[{value:"Description",id:"description",children:[]},{value:"Vulnerable Code Example",id:"vulnerable-code-example",children:[]},{value:"Mitigation",id:"mitigation",children:[]},{value:"Risk Assessment",id:"risk-assessment",children:[]},{value:"References",id:"references",children:[]}],c={toc:l};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"description"},"Description"),Object(i.b)("p",null,"The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. "),Object(i.b)("p",null,"Use-after-free errors have two common and sometimes overlapping causes:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Error conditions and other exceptional circumstances."),Object(i.b)("li",{parentName:"ul"},"Confusion over which part of the program is responsible for freeing the memory.")),Object(i.b)("p",null,"In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process."),Object(i.b)("h2",{id:"vulnerable-code-example"},"Vulnerable Code Example"),Object(i.b)("p",null,"In this vulnerable code example, the type of a message is used to determine how to process the message itself. It is assumed that message_type is an integer and message is a pointer to an array of characters that were allocated dynamically. If ",Object(i.b)("inlineCode",{parentName:"p"},"message_type")," equals ",Object(i.b)("inlineCode",{parentName:"p"},"value_1"),", the message is processed accordingly. A similar operation occurs when ",Object(i.b)("inlineCode",{parentName:"p"},"message_type")," equals ",Object(i.b)("inlineCode",{parentName:"p"},"value_2"),". However, if ",Object(i.b)("inlineCode",{parentName:"p"},"message_type == value_1")," evaluates to true and ",Object(i.b)("inlineCode",{parentName:"p"},"message_type == value_2")," also evaluates to true, then message is freed twice, resulting in a double-free vulnerability."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},"\nchar *message;\nint message_type;\n \n/* Initialize message and message_type */\n \nif (message_type == value_1) {\n  /* Process message type 1 */\n  free(message);\n}\n/* ...*/\nif (message_type == value_2) {\n   /* Process message type 2 */\n  free(message);\n}\n")),Object(i.b)("h2",{id:"mitigation"},"Mitigation"),Object(i.b)("p",null,"Calling ",Object(i.b)("inlineCode",{parentName:"p"},"free()")," on a null pointer results in no action being taken by ",Object(i.b)("inlineCode",{parentName:"p"},"free()"),". Setting message to ",Object(i.b)("inlineCode",{parentName:"p"},"NUL"),"L after it is freed eliminates the possibility that the message pointer can be used to free the same memory more than once."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},"char *message;\nint message_type;\n \n/* Initialize message and message_type */\n \nif (message_type == value_1) {\n  /* Process message type 1 */\n  free(message);\n  message = NULL;\n}\n/* ... */\nif (message_type == value_2) {\n  /* Process message type 2 */\n  free(message);\n  message = NULL;\n}\n")),Object(i.b)("h2",{id:"risk-assessment"},"Risk Assessment"),Object(i.b)("p",null,"Setting pointers to NULL or to another valid value after memory is freed is a simple and easily implemented solution for reducing dangling pointers. Dangling pointers can result in freeing memory multiple times or in writing to memory that has already been freed. Both of these problems can lead to an attacker executing arbitrary code with the permissions of the vulnerable process."),Object(i.b)("h2",{id:"references"},"References"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://cwe.mitre.org/data/definitions/416.html"},"CWE-416: Use After Free")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://www.informit.com/articles/article.aspx?p=2088511"},"C Secure Coding Rules: Past, Present, and Future, Seacord, Robert C, 2013."))))}u.isMDXComponent=!0},136:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),u=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,b=p["".concat(s,".").concat(d)]||p[d]||m[d]||i;return n?a.a.createElement(b,o(o({ref:t},c),{},{components:n})):a.a.createElement(b,o({ref:t},c))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);