(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{136:function(e,n,t){"use strict";t.d(n,"a",(function(){return m})),t.d(n,"b",(function(){return p}));var r=t(0),i=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),u=function(e){var n=i.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=u(e.components);return i.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=i.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=u(t),b=r,p=m["".concat(o,".").concat(b)]||m[b]||d[b]||a;return t?i.a.createElement(p,l(l({ref:n},c),{},{components:t})):i.a.createElement(p,l({ref:n},c))}));function p(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=b;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<a;c++)o[c]=t[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},91:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return u}));var r=t(3),i=t(8),a=(t(0),t(136)),o={title:"Double-Free Vulnerability",sidebar_label:"Double-Free Vulnerability"},l={unversionedId:"security_awareness/languages/C/DoubleFree",id:"security_awareness/languages/C/DoubleFree",isDocsHomePage:!1,title:"Double-Free Vulnerability",description:"Description",source:"@site/docs/security_awareness/languages/C/DoubleFree.md",slug:"/security_awareness/languages/C/DoubleFree",permalink:"/docs/security_awareness/languages/C/DoubleFree",version:"current",sidebar_label:"Double-Free Vulnerability",sidebar:"someSidebar",previous:{title:"Memory Leak Vulnerability",permalink:"/docs/security_awareness/languages/C/MemoryLeak"},next:{title:"Integer Overflow or Wraparound Vulnerability",permalink:"/docs/security_awareness/languages/C/IntegerOverflow"}},s=[{value:"Description",id:"description",children:[]},{value:"Vulnerable Code Example",id:"vulnerable-code-example",children:[]},{value:"Mitigation",id:"mitigation",children:[]},{value:"Risk Assessment",id:"risk-assessment",children:[]},{value:"References",id:"references",children:[]}],c={toc:s};function u(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"description"},"Description"),Object(a.b)("p",null,"Allocating and freeing memory in different modules and levels of abstraction may make it difficult to determine when and if a block of memory has been freed, leading to programming defects, such as double-free vulnerabilities. When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to ",Object(a.b)("inlineCode",{parentName:"p"},"malloc()")," to return the same pointer. If ",Object(a.b)("inlineCode",{parentName:"p"},"malloc()")," returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack."),Object(a.b)("p",null,"To avoid this situation, memory should be allocated and freed at the same level of abstraction and, ideally, in the same code module. This includes the use of the following memory allocation and deallocation functions described in subclause."),Object(a.b)("h2",{id:"vulnerable-code-example"},"Vulnerable Code Example"),Object(a.b)("p",null,"This noncompliant code example shows a double-free vulnerability resulting from memory being allocated and freed at differing levels of abstraction. In this example, memory for the list array is allocated in the ",Object(a.b)("inlineCode",{parentName:"p"},"process_list()")," function. The array is then passed to the ",Object(a.b)("inlineCode",{parentName:"p"},"verify_size()")," function that performs error checking on the size of the list. If the size of the list is below a minimum size, the memory allocated to the list is freed, and the function returns to the caller. The calling function then frees this same memory again, resulting in a double-free and potentially exploitable vulnerability."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-c"},"enum { MIN_SIZE_ALLOWED = 32 };\n \nint verify_size(char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    free(list);\n    return -1;\n  }\n  return 0;\n}\n \nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n \n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n \n  /* Continue processing list */\n \n  free(list);\n}\n")),Object(a.b)("p",null,"The call to free memory in the ",Object(a.b)("inlineCode",{parentName:"p"},"verify_size()")," function takes place in a subroutine of the ",Object(a.b)("inlineCode",{parentName:"p"},"process_list()"),' function, at a different level of abstraction from the allocation, resulting in a violation of this recommendation. The memory deallocation also occurs in error-handling code, which is frequently not as well tested as "green paths" through the code.'),Object(a.b)("h2",{id:"mitigation"},"Mitigation"),Object(a.b)("p",null,"To correct this problem, the error-handling code in ",Object(a.b)("inlineCode",{parentName:"p"},"verify_size()")," is modified so that it no longer frees list. This change ensures that list is freed only once, at the same level of abstraction, in the ",Object(a.b)("inlineCode",{parentName:"p"},"process_list()")," function."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-c"},"enum { MIN_SIZE_ALLOWED = 32 };\n \nint verify_size(const char *list, size_t size) {\n  if (size < MIN_SIZE_ALLOWED) {\n    /* Handle error condition */\n    return -1;\n  }\n  return 0;\n}\n \nvoid process_list(size_t number) {\n  char *list = (char *)malloc(number);\n \n  if (list == NULL) {\n    /* Handle allocation error */\n  }\n \n  if (verify_size(list, number) == -1) {\n      free(list);\n      return;\n  }\n \n  /* Continue processing list */\n \n  free(list);\n}\n")),Object(a.b)("h2",{id:"risk-assessment"},"Risk Assessment"),Object(a.b)("p",null,"The mismanagement of memory can lead to freeing memory multiple times or writing to already freed memory. Both of these coding errors can result in an attacker executing arbitrary code with the permissions of the vulnerable process. Memory management errors can also lead to resource depletion and denial-of-service attacks."),Object(a.b)("h2",{id:"references"},"References"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://cwe.mitre.org/data/definitions/415.html"},"CWE-415: Double Free")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("a",{parentName:"li",href:"https://wiki.sei.cmu.edu/confluence/display/c/AA.+Bibliography#AA.Bibliography-ISO-IEC9899-2011"},"Programming Languages\u2014C, 3rd ed (ISO/IEC 9899:2011). Geneva, Switzerland: ISO, 2011."))))}u.isMDXComponent=!0}}]);