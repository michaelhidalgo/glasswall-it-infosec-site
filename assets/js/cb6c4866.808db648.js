(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{118:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(8),i=(n(0),n(136)),l={title:"Buffer Overflow",sidebar_label:"Buffer Overflow"},o={unversionedId:"security_awareness/languages/C/BufferOverflow",id:"security_awareness/languages/C/BufferOverflow",isDocsHomePage:!1,title:"Buffer Overflow",description:"Description",source:"@site/docs/security_awareness/languages/C/BufferOverflow.md",slug:"/security_awareness/languages/C/BufferOverflow",permalink:"/docs/security_awareness/languages/C/BufferOverflow",version:"current",sidebar_label:"Buffer Overflow",sidebar:"someSidebar",previous:{title:"Empty Try-Catch Block",permalink:"/docs/security_awareness/languages/Csharp/EmptyTryCatch"},next:{title:"Use After Free (UAF) Vulnerability",permalink:"/docs/security_awareness/languages/C/uaf"}},c=[{value:"Description",id:"description",children:[]},{value:"Vulnerabilities",id:"vulnerabilities",children:[]},{value:"1. gets()",id:"1-gets",children:[{value:"Mitigation",id:"mitigation",children:[]}]},{value:"2. strcpy",id:"2-strcpy",children:[{value:"Mitigation",id:"mitigation-1",children:[]}]},{value:"3. sprintf",id:"3-sprintf",children:[{value:"Mitigation",id:"mitigation-2",children:[]}]},{value:"4. printf",id:"4-printf",children:[{value:"Mitigation",id:"mitigation-3",children:[]}]},{value:"5. File opening",id:"5-file-opening",children:[{value:"Symbolic link attack",id:"symbolic-link-attack",children:[]},{value:"Mitigation",id:"mitigation-4",children:[]}]},{value:"General Mitigation Strategies",id:"general-mitigation-strategies",children:[]},{value:"References",id:"references",children:[]}],s={toc:c};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"description"},"Description"),Object(i.b)("p",null,"Buffer overflows are probably one of the most vicious tools available to an attacker. A small honest mistake made by a developer with SETUID root permissions can mean catastrophe. "),Object(i.b)("p",null,"A buffer overflow is the technique of overwriting machine code with an attackers own code, this occurs when a program takes input from a user in low-level languages such as c, c++ without checking its size. It can be used to gain root access."),Object(i.b)("p",null,"To effectively mitigate buffer overflow vulnerabilities, it is important to understand what buffer overflows are, what dangers they pose to your applications, and what techniques attackers use to successfully exploit these vulnerabilities."),Object(i.b)("h2",{id:"vulnerabilities"},"Vulnerabilities"),Object(i.b)("h2",{id:"1-gets"},"1. gets()"),Object(i.b)("p",null,"The stdio gets() function does not check for buffer length and always results in a vulnerability."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <signal.h>\n#include <stdio.h>\n#include <string.h>\nint main () {\n    char username[8];\n    int allow = 0;\n    printf("Enter your username, please: ");\n    gets(username); // user inputs "malicious"\n    if (grantAccess(username)) {\n        allow = 1;\n    }\n    if (allow != 0) { // has been overwritten by the overflow of the username.\n        privilegedAction();\n    }\n    return 0;\n}\n')),Object(i.b)("h3",{id:"mitigation"},"Mitigation"),Object(i.b)("p",null,"Prefer using fgets (and dynamically allocated memory!):"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n\u200b\nint main (void) \n{\n\n\n    char *username, *p;\n    int allow = 0;\n \n    username = malloc(LENGTH);   \n    if (!username)\n        return EXIT_FAILURE;\n\u200b\n    printf("Enter your username, please: ");\n    fgets(username, sizeof username, stdin);   \n\u200b\n \n    if (grantAccess(username))\n        privilegedAction();\n \n    free(username);\n \n    return 0;\n}\n')),Object(i.b)("h2",{id:"2-strcpy"},"2. strcpy"),Object(i.b)("p",null,"The strcpy built-in function does not check buffer lengths and may very well overwrite memory zone contiguous to the intended destination. In fact, the whole family of functions is similarly vulnerable: strcpy, strcat and strcmp."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'char str1[10];\nchar str2[]="abcdefghijklmn";\nstrcpy(str1,str2);\n')),Object(i.b)("h3",{id:"mitigation-1"},"Mitigation"),Object(i.b)("p",null,"The best way to mitigate this issue is to use strlcpy if it is readily available (which is only the case on BSD systems). However, it is very simple to define it yourself, as shown below:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'\n#include <stdio.h>\n#ifndef strlcpy\n#define strlcpy(dst,src,sz) snprintf((dst), (sz), "%s", (src))\n#endif\n \nenum { BUFFER_SIZE = 10 };\n \nint main() {\n    char dst[BUFFER_SIZE];\n    char src[] = "abcdefghijk";\n \n    int buffer_length = strlcpy(dst, src, BUFFER_SIZE);\n \n    if (buffer_length >= BUFFER_SIZE) {\n        printf("String too long: %d (%d expected)\\n",\n                buffer_length, BUFFER_SIZE-1);\n    }\n \n    printf("String copied: %s\\n", dst);\n \n    return 0;\n}\n')),Object(i.b)("h2",{id:"3-sprintf"},"3. sprintf"),Object(i.b)("p",null,"Just as the previous functions, sprintf does not check the buffer boundaries and is vulnerable to overflows."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n \nenum { BUFFER_SIZE = 10 };\n \nint main() {\n    char buffer[BUFFER_SIZE];\n    int check = 0;\n \n    sprintf(buffer, "%s", "This string is too long!");\n \n    printf("check: %d", check); /* This will not print 0! */\n \n    return EXIT_SUCCESS;\n}\n')),Object(i.b)("h3",{id:"mitigation-2"},"Mitigation"),Object(i.b)("p",null,"Prefer using snprintf, which has the double advantage of preventing buffers overflows and returning the minimal size of buffer needed to fit the whole formatted string."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n \nenum { BUFFER_SIZE = 10 };\n \nint main() {\n    char buffer[BUFFER_SIZE];\n \n    int length = snprintf(buffer, BUFFER_SIZE, "%s%s", "long-name", "suffix");\n \n    if (length >= BUFFER_SIZE) {\n        /* handle string truncation! */\n    }\n \n    return EXIT_SUCCESS;\n}\n')),Object(i.b)("h2",{id:"4-printf"},"4. printf"),Object(i.b)("p",null,"One other vulnerability category is concerned with string formatting attacks, those can cause information leakage, overwriting of memory, \u2026 This error can be exploited in any of the following functions: printf, fprintf, sprintf and snprintf, i.e. all functions that take a \u201cformat string\u201d as argument."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#FormatString.c\n#include <stdio.h>\n \nint main(int argc, char **argv) {\n    char *secret = "This is a secret!\\n";\n \n    printf(argv[1]);\n \n    return 0;\n}\n')),Object(i.b)("p",null,"Now, this code, if compiled with the -mpreferred-stack-boundary=2 option (on a 32-bit platform; on 64-bit things work slightly differently, but the code still is vulnerable!), can yield interesting results."),Object(i.b)("p",null,"If called with ",Object(i.b)("inlineCode",{parentName:"p"},"./FormatString %s"),", it will print the secret string."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},"$ gcc -mpreferred-stack-boundary=2 FormatString.c -o FormatString\n$ ./FormatString %s\nThis is a secret!\n$\n")),Object(i.b)("h3",{id:"mitigation-3"},"Mitigation"),Object(i.b)("p",null,"It's really simple: always hardcode the format string. At least, never let it come directly from any user's input."),Object(i.b)("h2",{id:"5-file-opening"},"5. File opening"),Object(i.b)("p",null,"Much care must be taken when opening files, as many issues can arise. Out of the many ways file handling can be attacked, we will only present two brief examples below."),Object(i.b)("h3",{id:"symbolic-link-attack"},"Symbolic link attack"),Object(i.b)("p",null,"It is a good idea to check whether a file exists or not before creating it. However, a malicious user might create a file (or worse, a symbolic link to a critical system file) between your check and the moment you actually use the file."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n \n#define MY_TMP_FILE "/tmp/file.tmp"\n \n \nint main(int argc, char* argv[])\n{\n    FILE * f;\n    if (!access(MY_TMP_FILE, F_OK)) {\n        printf ("File exists!\\n");\n        return EXIT_FAILURE;\n    }\n    /* At this point the attacker creates a symlink from /tmp/file.tmp to /etc/passwd */\n    tmpFile = fopen(MY_TMP_FILE, "w");\n \n    if (tmpFile == NULL) {\n        return EXIT_FAILURE;\n    }\n \n    fputs("Some text...\\n", tmpFile);\n \n    fclose(tmpFile);\n    /* You successfully overwrote /etc/passwd (at least if you ran this as root) */\n \n    return EXIT_SUCCESS;\n}\n')),Object(i.b)("h3",{id:"mitigation-4"},"Mitigation"),Object(i.b)("p",null,"Avoid the race condition by accessing directly the file, and don't overwrite it if it already exists."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-c"},'#include <unistd.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n \n#define MY_TMP_FILE "/tmp/file.tmp"\n \nenum { FILE_MODE = 0600 };\n \nint main(int argc, char* argv[])\n{\n    int fd;\n    FILE* f;\n \n    /* Remove possible symlinks */\n    unlink(MY_TMP_FILE);\n    /* Open, but fail if someone raced us and restored the symlink (secure version of fopen(path, "w") */\n    fd = open(MY_TMP_FILE, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE);\n    if (fd == -1) {\n        perror("Failed to open the file");\n        return EXIT_FAILURE;\n    }\n    /* Get a FILE*, as they are easier and more efficient than plan file descriptors */\n    f = fdopen(fd, "w");\n    if (f == NULL) {\n        perror("Failed to associate file descriptor with a stream");\n        return EXIT_FAILURE;\n    }\n    fprintf(f, "Hello, world\\n");\n    fclose(f);\n    /* fd is already closed by fclose()!!! */\n    return EXIT_SUCCESS;\n}\n')),Object(i.b)("h2",{id:"general-mitigation-strategies"},"General Mitigation Strategies"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Address space randomization (ASLR)\u2014randomly moves around the address space locations of data regions. Typically, buffer overflow attacks need to know the locality of executable code, and randomizing address spaces makes this virtually impossible."),Object(i.b)("li",{parentName:"ol"},"Data execution prevention\u2014flags certain areas of memory as non-executable or executable, which stops an attack from running code in a non-executable region."),Object(i.b)("li",{parentName:"ol"},"Structured exception handler overwrite protection (SEHOP)\u2014helps stop malicious code from attacking Structured Exception Handling (SEH), a built-in system for managing hardware and software exceptions. It thus prevents an attacker from being able to make use of the SEH overwrite exploitation technique. At a functional level, an SEH overwrite is achieved using a stack-based buffer overflow to overwrite an exception registration record, stored on a thread\u2019s stack."),Object(i.b)("li",{parentName:"ol"},"Avoid functions that do no bounds checking")),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",{parentName:"tr",align:null},"Instead Of"),Object(i.b)("th",{parentName:"tr",align:"center"},"Use"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"gets()"),Object(i.b)("td",{parentName:"tr",align:"center"},"fgets()")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"strcpy()"),Object(i.b)("td",{parentName:"tr",align:"center"},"strncpy()")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"strcat()"),Object(i.b)("td",{parentName:"tr",align:"center"},"strncat()")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"sprintf()"),Object(i.b)("td",{parentName:"tr",align:"center"},"bcopy()")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"scanf()"),Object(i.b)("td",{parentName:"tr",align:"center"},"bzero()")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"sscanf()"),Object(i.b)("td",{parentName:"tr",align:"center"},"memcpy(), memset()")))),Object(i.b)("ol",{start:5},Object(i.b)("li",{parentName:"ol"},"Be especially careful programming and/or installing setuid root programs and programs that run as root. These are the programs that allow an attacker to acquire a root shell."),Object(i.b)("li",{parentName:"ol"},"Be careful when using for and while loops that copy data from one variable to another. Make sure the bounds are checked."),Object(i.b)("li",{parentName:"ol"},"Review legacy software code for security problems.")),Object(i.b)("h2",{id:"references"},"References"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://owasp.org/www-community/attacks/Buffer_overflow_attack"},"OWASP Buffer Overflow Attack")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://www.veracode.com/security/buffer-overflow"},"Veracode: What Is a Buffer Overflow? Learn About Buffer Overrun Vulnerabilities, Exploits & Attacks")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://cwe.mitre.org/index.html"},"CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://cwe.mitre.org/data/definitions/119.html"},"CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",{parentName:"li",href:"https://cwe.mitre.org/data/definitions/134.html"},"CWE-134: Use of Externally-Controlled Format String"))))}u.isMDXComponent=!0},136:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),u=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},b=function(e){var t=u(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},p=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),b=u(n),p=r,d=b["".concat(l,".").concat(p)]||b[p]||f[p]||i;return n?a.a.createElement(d,o(o({ref:t},s),{},{components:n})):a.a.createElement(d,o({ref:t},s))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);